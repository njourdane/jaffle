#samples({
#  bd: ['bd/BT0AADA.wav','bd/BT0AAD0.wav'],
#  sd: ['sd/rytm-01-classic.wav','sd/rytm-00-hard.wav'],
#  hh: ['hh27/000_hh27closedhh.wav','hh/000_hh3closedhh.wav'],
#}, 'github:tidalcycles/Dirt-Samples/master/');
Samples:
- bd: [ bd/BT0AADA.wav, bd/BT0AAD0.wav ]
  sd: [ sd/rytm-01-classic.wav, sd/rytm-00-hard.wav ]
  hh: [ hh27/000_hh27closedhh.wav, hh/000_hh3closedhh.wav ]
- github:tidalcycles/Dirt-Samples/master/

# setVoicingRange('lefthand', ['E3', 'G4']);
SetVoicingRange:
- lefthand
- [E3, G4]

# await loadOrc('github:kunstmusik/csound-live-code/master/livecode.orc')
^LoadOrc: github:kunstmusik/csound-live-code/master/livecode.orc

# await loadCsound`
# instr CoolSynth
#     ...
#     asig *= linsegr:a(0, iattack, 1, idecay, isustain, iduration, isustain, irelease, 0)
#     out(asig, asig)
# endin`
^LoadCsound: >
  instr CoolSynth
      ...
      asig *= linsegr:a(0, iattack, 1, idecay, isustain, iduration, isustain, irelease, 0)
      out(asig, asig)
  endin

Cat:

# note("c a f e").csound('FM1')
- Note: c a f e
  csound: FM1

# "<0 2 [4 6](3,4,2) 3*2>"
# .scale('D minor')
# .note()
# .csound('CoolSynth')
- M: <0 2 [4 6](3,4,2) 3*2>
  scale: D minor
  note:
  csound: CoolSynth

# s("hh*16").lpf(saw.range(200,4000))
- S: hh*16
  lpf:
    Saw:
    range: [200, 4000]

# -> need to create functions for signals: saw, sine, square, etc.

# note("c2 [eb3,g3]".add("<0 <1 -1>>").add("0,7"))
- Note:
    M: c2 [eb3,g3]
    add: <0 <1 -1>>
  add: 0,7

# n("0 2 4 6").scale("C:minor").jux(rev)
- N: 0 2 4 6
  scale: C:minor
  jux:
    Rev:

# note("c2 [eb3,g3]").sometimes(x=>x.speed("-1"))
- Note: c2 [eb3,g3]
  sometimes:
    Set:
    speed: -1

# s("bd sd, hh*4").off(1/8, x=>x.speed(2))
- S: bd sd, hh*4
  off:
  - 1/8
  - Set:
    speed: 2

# cat('c', 'e', 'g').note().log()
- Cat: [c, e, g]
  note:
  log:

# "50 60 70".add("<0 1 2>").note().room(.1).log()
- M: 50 60 70
  add: <0 1 2>
  note:
  room: .1
  log:

# s("lt ht mt ht hh").juxBy("<0 .5 1>/2", rev)
- S: lt ht mt ht hh
  juxBy: [ <0 .5 1>/2 , rev: ]

# stack( "50 60 70".add("<0 1 2 3>").note() )
- Stack:
    M: 50 60 70
    add: <0 1 2 3>
    note:

# stack( "50 60 70".add("<0 1 2 3>").note(), "80 90".note() )
- Stack:
  - M: 50 60 70
    add: <0 1 2 3>
    note:
  - M: 80 90
    note:

# note("c a f e").ccn(74).ccv(sine.slow(4)).midi()
- Note: c a f e
  ccn: 74
  ccv:
  - Sine:
    slow: 4
  midi:

# sound(`bd*2, ~ cp, 
#        ~ ~ ~ oh, hh*4,
#        [~ casio]*2`)
- Sound: >
    bd*2, ~ cp, 
    ~ ~ ~ oh, hh*4,
    [~ casio]*2

# cat(e5, b4, [d5, c5]).note() # same as: cat("e5", "b4", ["d5", "c5"]).note()
- Cat: [e5, b4, [d5, c5]]
  note:

# s("hh*2").cat(note("c2(3,8)"))
- S: hh*2
  cat:
    note: c2(3,8)

# timeCat([3,e3],[1, g3]).note()
- TimeCat: [ [3, e3] , [1, g3] ]
  note:

# "bd ~".stack("hh ~".early(.1)).s()
- M: bd ~
  stack:
    M: hh ~
    early: .1
  s:

# note(saw.range(0,12).segment(24)).add(40)
- Note:
    Saw:
    range: [0, 12]
    segment: 24
  add: 40

# "0 1 2 3 4 3 2 1".inside(4, rev).scale('C major').note()
- M: 0 1 2 3 4 3 2 1
  inside: [4, rev:]
  scale: C major
  note:

# note(irand(8).segment(4).scale('C3 minor')).ribbon(1337, 2)
- Note:
    Irand: 8
    segment: 4
    scale: C3 minor
  ribbon: [1337, 2]

# const scale = cat('C3 dorian','Bb2 major').slow(4);
# stack(
#   "2*4".add(12).scale(scale)
#   .off(1/8, scaleTranspose("2")).fast(2)
#   .scaleTranspose("<0 1 2 1>").hush(),
#   "<0 1 2 3>(3,8,2)"
#   .scale(scale)
#   .off(1/4, scaleTranspose("2,4"))
# )
- Stack:
  - M: 2*4
    add: 12
    scale: &scale
      Cat: [ C3 dorian, Bb2 major ]
      slow: 4
    off: [1/8, ScaleTranspose: 2]
    fast: 2
    scaleTranspose: <0 1 2 1>
    hush:
  - M: <0 1 2 3>(3,8,2)
    scale: *scale
    off: [1/4, ScaleTranspose: '2,4']

# cat({note:'c'},{note:'e'},{note:'g'}).log()
- Cat:
  - Note: c
  - Note: e
  - Note: g
  log:

# s("bd sd,hh*4").cutoff(perlin.range(500,2000))
- S: bd sd,hh*4
  cutoff:
    Perlin:
    range: [500, 2000]

# irand(8).struct("x(3,8)").scale('C minor').note()
- Irand: 8
  struct: x(3,8)
  scale: C minor
  note:

# "c3 eb3 g3".when("<0 1>/2", x=>x.sub(5)).note()
- M: c3 eb3 g3
  when:
  - <0 1>/2
  - Set:
    sub: 5
  note:

# note("<[c,eb,g]!2 [c,f,ab] [d,f,ab]>")
# .arpWith(haps => haps[2])
- Note: <[c,eb,g]!2 [c,f,ab] [d,f,ab]>
  arpWith: { Set: , get: 2 }

# "<0 [2 4]>".echoWith(4, 1/8, (p,n) => p.add(n*2))
- M: <0 [2 4]>
  echoWith:
  - 4
  - 1/8
  - Set: $n
    add:
      Mul: [ $n, 2 ]

# stack("<C^7 A7 Dm7 G7>".voicings('lefthand'), "<C3 A2 D3 G2>").note()
- Stack: 
  - M: <C^7 A7 Dm7 G7>
    voicings: lefthand
  - M: <C3 A2 D3 G2>
  note:

# "<C^7 A7b13 Dm7 G7>".layer(
#   l => l.voicings('lefthand').struct("~ x").note(),
#   l => l.rootNotes(2).note().s('sawtooth').cutoff(800)
# )
- M: <C^7 A7b13 Dm7 G7>
  layer:
  - Set:
    voicings: lefthand
    struct: ~ x
    note:
  - Set:
    rootNotes: 2
    note:
    s: sawtooth
    cutoff: 800
